{"ast":null,"code":"import _objectSpread from \"/Users/benjamindordoigne/Desktop/WMCA-Opportunities-App/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nvar _jsxFileName = \"/Users/benjamindordoigne/Desktop/WMCA-Opportunities-App/src/components/views/bloglist/bloglist.jsx\";\nimport React, { Component } from \"react\";\nimport { connect } from \"react-redux\"; // import actions\n\nimport { fetchLoading, fetchBlogs, fetchSearch, fetchVisibleResults } from \"../../../actions/index\"; // import components\n\nimport Sidebar from \"../../sidebar/sidebar\";\nimport Header from \"../../header/header\";\nimport BlogSummary from \"../../blogSummary/blogSummary\";\n\nclass BlogList extends Component {\n  constructor(...args) {\n    super(...args);\n\n    this.onFormSubmit = event => {\n      event.preventDefault();\n    };\n\n    this.onChangeInput = event => {\n      // destructure props\n      const dispatch = this.props.dispatch; // prevent search box from submitting any searches\n\n      event.preventDefault(); // dispatch the action on key change to update the state of search term\n\n      dispatch(fetchSearch(event.target.value));\n    };\n\n    this.infiniteScroll = () => {\n      // hold the stories container and the last article in a const variable\n      const articleContainer = document.getElementById(\"stories\");\n      const lastArticle = document.querySelector(\"#stories > article:last-of-type\"); // listen out for scroll events\n\n      document.addEventListener(\"scroll\", () => {\n        // we're checking if the article is present\n        // as we don't want the function to run an error\n        if (lastArticle !== null) {\n          // check if the article container height minus the window scroll is\n          // equal to or less than the last article height\n          if (articleContainer.scrollHeight - window.scrollY <= lastArticle.scrollHeight) {\n            // destructure props\n            const dispatch = this.props.dispatch; // dispatch the action so we can update the number of visible results\n\n            dispatch(fetchVisibleResults());\n          }\n        }\n      });\n    };\n  }\n\n  componentDidMount() {\n    // destructure props\n    const _this$props = this.props,\n          fetchLoading = _this$props.fetchLoading,\n          fetchBlogs = _this$props.fetchBlogs; // display results as soon as we've fetched api is resolved\n\n    fetchLoading();\n    fetchBlogs();\n  } // function is used for the search box,\n  // preventing form from submitting on press of enter key\n\n\n  renderBlogs() {\n    // destructure props\n    const _this$props2 = this.props,\n          blogs = _this$props2.blogs,\n          searchTerm = _this$props2.searchTerm,\n          visibleResults = _this$props2.visibleResults,\n          match = _this$props2.match,\n          eligibilities = _this$props2.eligibilities,\n          opportunities = _this$props2.opportunities,\n          skilllevels = _this$props2.skilllevels,\n          age = _this$props2.age,\n          where = _this$props2.where; // set a const variable check if\n    // a searchterm has been entered and filter blogs\n\n    const filteredBlogs = blogs && blogs.ChildPages // order blog childpages by most recent post\n    .sort((a, b) => b.PubDate > a.PubDate ? 1 : -1) // filter blog posts if a searchterm has been entered\n    .filter(blog => {\n      if (searchTerm) {\n        const searchValue = searchTerm.toLowerCase();\n        return Object.values(blog).some(value => value.toString().toLowerCase().includes(searchValue));\n      } // just return the blog if no searchterm is entered\n\n\n      return blog;\n    }) // filter this by selected skilllevel in the sidebar links\n    .filter(blog => {\n      // we're looking at the match params to see if skilllevel is defined\n      // if it is, we convert the skilllevels in the blog to a string, and lowercase\n      // then check if the array of skilllevels includes/matches that of the params\n      if (match.params.skilllevel !== undefined) {\n        let Array_SkillLevels = [];\n        Array_SkillLevels.push(blog.SkillLevel);\n        return Array_SkillLevels.some(value => value.toString().toLowerCase().includes(match.params.skilllevel));\n      } // just return all the blogs if params skilllevel is undefined\n\n\n      return blog;\n    }) // filter this by selected category in the sidebar links\n    .filter(blog => {\n      // we're looking at the match params to see if category is defined\n      // if it is, we convert the categories in the blog to a string, and lowercase\n      // then check if the array of categories includes/matches that of the params\n      if (match.params.category !== undefined) {\n        return Object.values(blog.Category).some(value => value.toString().toLowerCase().includes(match.params.category));\n      } // just return all the blogs if params category is undefined\n\n\n      return blog;\n    }).filter(blog => {\n      // we're looking at the match params to see if opportunity is defined\n      // if it is, we convert the opportunities in the blog to a string, and lowercase\n      // then check if the array of opportunities includes/matches that of the params\n      if (match.params.opportunity !== undefined) {\n        return Object.values(blog.Opportunity).some(value => value.toString().toLowerCase().includes(match.params.opportunity));\n      } // just return all the blogs if params opportunity is undefined\n\n\n      return blog;\n    }).filter(blog => {\n      // we're looking at the match params to see if category is defined\n      // if it is, we convert the categories in the blog to a string, and lowercase\n      // then check if the array of categories includes/matches that of the params\n      if (match.params.eligibility !== undefined) {\n        return Object.values(blog.Eligibility).some(value => value.toString().toLowerCase().includes(match.params.eligibility));\n      } // just return all the blogs if params category is undefined\n\n\n      return blog;\n    }).filter(blog => {\n      // we're looking at the match params to see if category is defined\n      // if it is, we convert the categories in the blog to a string, and lowercase\n      // then check if the array of categories includes/matches that of the params\n      if (match.params.age !== undefined) {\n        return Object.values(blog.Age).some(value => value.toString().toLowerCase().includes(match.params.age));\n      } // just return all the blogs if params category is undefined\n\n\n      return blog;\n    }).filter(blog => {\n      // we're looking at the match params to see if category is defined\n      // if it is, we convert the categories in the blog to a string, and lowercase\n      // then check if the array of categories includes/matches that of the params\n      if (match.params.where !== undefined) {\n        console.log(\"Running Where filter\");\n        return Object.values(blog.Where).some(value => value.toString().toLowerCase().includes(match.params.where));\n      } // just return all the blogs if params category is undefined\n\n\n      return blog;\n    }).filter(blog => {\n      //AGE\n      // we're looking at the match params to see if category is defined\n      // if it is, we convert the categories in the blog to a string, and lowercase\n      // then check if the array of categories includes/matches that of the params\n      if (match.params.age !== undefined) {\n        console.log(\"Running Age filter\");\n        return Object.values(blog.Age).some(value => value.toString().toLowerCase().includes(match.params.age));\n      } // just return all the blogs if params category is undefined\n\n\n      return blog;\n    }); // return the data for the const varible set above in filteredBlogs\n\n    return filteredBlogs && // we only want to display as many blogs that are set in the\n    // visibleResults state, so we slice the const and map through the data\n    filteredBlogs.slice(0, visibleResults).map(blog => {\n      return React.createElement(BlogSummary, {\n        blog: blog,\n        key: blog.Id,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 218\n        },\n        __self: this\n      });\n    });\n  }\n\n  render() {\n    // destructure props\n    const _this$props3 = this.props,\n          match = _this$props3.match,\n          loading = _this$props3.loading,\n          blogs = _this$props3.blogs,\n          skilllevels = _this$props3.skilllevels,\n          categories = _this$props3.categories,\n          opportunities = _this$props3.opportunities,\n          eligibilities = _this$props3.eligibilities,\n          searchTerm = _this$props3.searchTerm,\n          visibleResults = _this$props3.visibleResults,\n          age = _this$props3.age,\n          where = _this$props3.where;\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 240\n      },\n      __self: this\n    }, React.createElement(Header, {\n      match: match,\n      pageTitle: \"Find an opportunity\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 241\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      className: \"container-wide bg-white pad-30\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 242\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"pure-g justify-between\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 243\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"pure-u-1 pure-u-md-1-4\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 244\n      },\n      __self: this\n    }, !loading && React.createElement(React.Fragment, null, React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 249\n      },\n      __self: this\n    }, \"Filter\"), React.createElement(Sidebar, {\n      skilllevels: skilllevels,\n      categories: categories,\n      match: match,\n      opportunities: opportunities,\n      match: match,\n      eligibilities: eligibilities,\n      age: age,\n      where: where,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 250\n      },\n      __self: this\n    }))), React.createElement(\"div\", {\n      className: \"pure-u-1 pure-u-md-5-8\",\n      id: \"stories\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 254\n      },\n      __self: this\n    }, loading && React.createElement(\"h2\", {\n      className: \"title is-3\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 256\n      },\n      __self: this\n    }, \"Loading...\"), this.renderBlogs(), blogs && this.renderBlogs().length < 1 && React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 262\n      },\n      __self: this\n    }, `There were no results found for '${searchTerm}'`), blogs && visibleResults < blogs.ChildPages.length && this.infiniteScroll()))));\n  }\n\n} // return store data to const variable 'mapStateToProps'\n\n\nconst mapStateToProps = state => {\n  return _objectSpread({}, state, {\n    loading: state.blogs.getLoading,\n    blogs: state.blogs.getBlogs,\n    skilllevels: state.blogs.getSkillLevels,\n    categories: state.blogs.getCategories,\n    opportunities: state.blogs.getOpportunities,\n    eligibilities: state.blogs.getEligibilities,\n    where: state.blogs.getWhere,\n    date: state.blogs.getDate,\n    age: state.blogs.getAge,\n    searchTerm: state.blogs.getSearch,\n    visibleResults: state.blogs.getVisibleResults\n  });\n}; // this is used to bind actions and dispatch actions\n\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    fetchLoading: () => {\n      dispatch(fetchLoading());\n    },\n    fetchBlogs: () => {\n      dispatch(fetchBlogs());\n    },\n    dispatch\n  };\n}; // connect a react component to our redux store\n\n\nexport default connect(mapStateToProps, mapDispatchToProps)(BlogList);","map":{"version":3,"sources":["/Users/benjamindordoigne/Desktop/WMCA-Opportunities-App/src/components/views/bloglist/bloglist.jsx"],"names":["React","Component","connect","fetchLoading","fetchBlogs","fetchSearch","fetchVisibleResults","Sidebar","Header","BlogSummary","BlogList","onFormSubmit","event","preventDefault","onChangeInput","dispatch","props","target","value","infiniteScroll","articleContainer","document","getElementById","lastArticle","querySelector","addEventListener","scrollHeight","window","scrollY","componentDidMount","renderBlogs","blogs","searchTerm","visibleResults","match","eligibilities","opportunities","skilllevels","age","where","filteredBlogs","ChildPages","sort","a","b","PubDate","filter","blog","searchValue","toLowerCase","Object","values","some","toString","includes","params","skilllevel","undefined","Array_SkillLevels","push","SkillLevel","category","Category","opportunity","Opportunity","eligibility","Eligibility","Age","console","log","Where","slice","map","Id","render","loading","categories","length","mapStateToProps","state","getLoading","getBlogs","getSkillLevels","getCategories","getOpportunities","getEligibilities","getWhere","date","getDate","getAge","getSearch","getVisibleResults","mapDispatchToProps"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,OAAT,QAAwB,aAAxB,C,CAEA;;AACA,SACEC,YADF,EAEEC,UAFF,EAGEC,WAHF,EAIEC,mBAJF,QAKO,wBALP,C,CAOA;;AACA,OAAOC,OAAP,MAAoB,uBAApB;AACA,OAAOC,MAAP,MAAmB,qBAAnB;AAEA,OAAOC,WAAP,MAAwB,+BAAxB;;AAEA,MAAMC,QAAN,SAAuBT,SAAvB,CAAiC;AAAA;AAAA;;AAAA,SAY/BU,YAZ+B,GAYhBC,KAAK,IAAI;AACtBA,MAAAA,KAAK,CAACC,cAAN;AACD,KAd8B;;AAAA,SAkB/BC,aAlB+B,GAkBfF,KAAK,IAAI;AACvB;AADuB,YAEfG,QAFe,GAEF,KAAKC,KAFH,CAEfD,QAFe,EAGvB;;AACAH,MAAAA,KAAK,CAACC,cAAN,GAJuB,CAMvB;;AACAE,MAAAA,QAAQ,CAACV,WAAW,CAACO,KAAK,CAACK,MAAN,CAAaC,KAAd,CAAZ,CAAR;AACD,KA1B8B;;AAAA,SA4B/BC,cA5B+B,GA4Bd,MAAM;AACrB;AACA,YAAMC,gBAAgB,GAAGC,QAAQ,CAACC,cAAT,CAAwB,SAAxB,CAAzB;AACA,YAAMC,WAAW,GAAGF,QAAQ,CAACG,aAAT,CAClB,iCADkB,CAApB,CAHqB,CAOrB;;AACAH,MAAAA,QAAQ,CAACI,gBAAT,CAA0B,QAA1B,EAAoC,MAAM;AACxC;AACA;AACA,YAAIF,WAAW,KAAK,IAApB,EAA0B;AACxB;AACA;AACA,cACEH,gBAAgB,CAACM,YAAjB,GAAgCC,MAAM,CAACC,OAAvC,IACAL,WAAW,CAACG,YAFd,EAGE;AACA;AADA,kBAEQX,QAFR,GAEqB,KAAKC,KAF1B,CAEQD,QAFR,EAGA;;AACAA,YAAAA,QAAQ,CAACT,mBAAmB,EAApB,CAAR;AACD;AACF;AACF,OAhBD;AAiBD,KArD8B;AAAA;;AAC/BuB,EAAAA,iBAAiB,GAAG;AAClB;AADkB,wBAEmB,KAAKb,KAFxB;AAAA,UAEVb,YAFU,eAEVA,YAFU;AAAA,UAEIC,UAFJ,eAEIA,UAFJ,EAIlB;;AACAD,IAAAA,YAAY;AACZC,IAAAA,UAAU;AACX,GAR8B,CAU/B;AACA;;;AA4CA0B,EAAAA,WAAW,GAAG;AACZ;AADY,yBAEgG,KAAKd,KAFrG;AAAA,UAEJe,KAFI,gBAEJA,KAFI;AAAA,UAEGC,UAFH,gBAEGA,UAFH;AAAA,UAEeC,cAFf,gBAEeA,cAFf;AAAA,UAE+BC,KAF/B,gBAE+BA,KAF/B;AAAA,UAEsCC,aAFtC,gBAEsCA,aAFtC;AAAA,UAEqDC,aAFrD,gBAEqDA,aAFrD;AAAA,UAEoEC,WAFpE,gBAEoEA,WAFpE;AAAA,UAEiFC,GAFjF,gBAEiFA,GAFjF;AAAA,UAEsFC,KAFtF,gBAEsFA,KAFtF,EAIZ;AACA;;AACA,UAAMC,aAAa,GACjBT,KAAK,IACLA,KAAK,CAACU,UAAN,CACE;AADF,KAEGC,IAFH,CAEQ,CAACC,CAAD,EAAIC,CAAJ,KAAWA,CAAC,CAACC,OAAF,GAAYF,CAAC,CAACE,OAAd,GAAwB,CAAxB,GAA4B,CAAC,CAFhD,EAGE;AAHF,KAIGC,MAJH,CAIUC,IAAI,IAAI;AACd,UAAIf,UAAJ,EAAgB;AACd,cAAMgB,WAAW,GAAGhB,UAAU,CAACiB,WAAX,EAApB;AACA,eAAOC,MAAM,CAACC,MAAP,CAAcJ,IAAd,EAAoBK,IAApB,CAAyBlC,KAAK,IACnCA,KAAK,CACFmC,QADH,GAEGJ,WAFH,GAGGK,QAHH,CAGYN,WAHZ,CADK,CAAP;AAMD,OATa,CAUd;;;AACA,aAAOD,IAAP;AACD,KAhBH,EAiBU;AAjBV,KAkBWD,MAlBX,CAkBkBC,IAAI,IAAI;AACd;AACA;AACA;AACA,UAAIb,KAAK,CAACqB,MAAN,CAAaC,UAAb,KAA4BC,SAAhC,EAA2C;AACzC,YAAIC,iBAAiB,GAAG,EAAxB;AACAA,QAAAA,iBAAiB,CAACC,IAAlB,CAAuBZ,IAAI,CAACa,UAA5B;AACA,eAAOF,iBAAiB,CAACN,IAAlB,CAAuBlC,KAAK,IACjCA,KAAK,CACFmC,QADH,GAEGJ,WAFH,GAGGK,QAHH,CAGYpB,KAAK,CAACqB,MAAN,CAAaC,UAHzB,CADK,CAAP;AAMD,OAba,CAcd;;;AACA,aAAOT,IAAP;AACD,KAlCX,EAoCE;AApCF,KAqCGD,MArCH,CAqCUC,IAAI,IAAI;AACd;AACA;AACA;AACA,UAAIb,KAAK,CAACqB,MAAN,CAAaM,QAAb,KAA0BJ,SAA9B,EAAyC;AACvC,eAAOP,MAAM,CAACC,MAAP,CAAcJ,IAAI,CAACe,QAAnB,EAA6BV,IAA7B,CAAkClC,KAAK,IAC5CA,KAAK,CACFmC,QADH,GAEGJ,WAFH,GAGGK,QAHH,CAGYpB,KAAK,CAACqB,MAAN,CAAaM,QAHzB,CADK,CAAP;AAMD,OAXa,CAYd;;;AACA,aAAOd,IAAP;AACD,KAnDH,EAoDGD,MApDH,CAoDUC,IAAI,IAAI;AACd;AACA;AACA;AACA,UAAIb,KAAK,CAACqB,MAAN,CAAaQ,WAAb,KAA6BN,SAAjC,EAA4C;AAC1C,eAAOP,MAAM,CAACC,MAAP,CAAcJ,IAAI,CAACiB,WAAnB,EAAgCZ,IAAhC,CAAqClC,KAAK,IAC/CA,KAAK,CACFmC,QADH,GAEGJ,WAFH,GAGGK,QAHH,CAGYpB,KAAK,CAACqB,MAAN,CAAaQ,WAHzB,CADK,CAAP;AAMD,OAXa,CAYd;;;AACA,aAAOhB,IAAP;AACD,KAlEH,EAmEGD,MAnEH,CAmEUC,IAAI,IAAI;AACd;AACA;AACA;AACA,UAAIb,KAAK,CAACqB,MAAN,CAAaU,WAAb,KAA6BR,SAAjC,EAA4C;AAC1C,eAAOP,MAAM,CAACC,MAAP,CAAcJ,IAAI,CAACmB,WAAnB,EAAgCd,IAAhC,CAAqClC,KAAK,IAC/CA,KAAK,CACFmC,QADH,GAEGJ,WAFH,GAGGK,QAHH,CAGYpB,KAAK,CAACqB,MAAN,CAAaU,WAHzB,CADK,CAAP;AAMD,OAXa,CAYd;;;AACA,aAAOlB,IAAP;AACD,KAjFH,EAkFGD,MAlFH,CAkFUC,IAAI,IAAI;AACd;AACA;AACA;AACA,UAAIb,KAAK,CAACqB,MAAN,CAAajB,GAAb,KAAqBmB,SAAzB,EAAoC;AAClC,eAAOP,MAAM,CAACC,MAAP,CAAcJ,IAAI,CAACoB,GAAnB,EAAwBf,IAAxB,CAA6BlC,KAAK,IACvCA,KAAK,CACFmC,QADH,GAEGJ,WAFH,GAGGK,QAHH,CAGYpB,KAAK,CAACqB,MAAN,CAAajB,GAHzB,CADK,CAAP;AAMD,OAXa,CAYd;;;AACA,aAAOS,IAAP;AACD,KAhGH,EAiGGD,MAjGH,CAiGUC,IAAI,IAAI;AACd;AACA;AACA;AACA,UAAIb,KAAK,CAACqB,MAAN,CAAahB,KAAb,KAAuBkB,SAA3B,EAAsC;AACpCW,QAAAA,OAAO,CAACC,GAAR,CAAY,sBAAZ;AACA,eAAOnB,MAAM,CAACC,MAAP,CAAcJ,IAAI,CAACuB,KAAnB,EAA0BlB,IAA1B,CAA+BlC,KAAK,IACzCA,KAAK,CACFmC,QADH,GAEGJ,WAFH,GAGGK,QAHH,CAGYpB,KAAK,CAACqB,MAAN,CAAahB,KAHzB,CADK,CAAP;AAMD,OAZa,CAad;;;AACA,aAAOQ,IAAP;AACD,KAhHH,EAiHGD,MAjHH,CAiHUC,IAAI,IAAI;AACd;AACA;AACA;AACA;AACA,UAAIb,KAAK,CAACqB,MAAN,CAAajB,GAAb,KAAqBmB,SAAzB,EAAoC;AAClCW,QAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AACA,eAAOnB,MAAM,CAACC,MAAP,CAAcJ,IAAI,CAACoB,GAAnB,EAAwBf,IAAxB,CAA6BlC,KAAK,IACvCA,KAAK,CACFmC,QADH,GAEGJ,WAFH,GAGGK,QAHH,CAGYpB,KAAK,CAACqB,MAAN,CAAajB,GAHzB,CADK,CAAP;AAMD,OAba,CAcd;;;AACA,aAAOS,IAAP;AACD,KAjIH,CAFF,CANY,CA2IZ;;AACA,WACEP,aAAa,IACb;AACA;AACAA,IAAAA,aAAa,CAAC+B,KAAd,CAAoB,CAApB,EAAuBtC,cAAvB,EAAuCuC,GAAvC,CAA2CzB,IAAI,IAAI;AACjD,aAAO,oBAAC,WAAD;AAAa,QAAA,IAAI,EAAEA,IAAnB;AAAyB,QAAA,GAAG,EAAEA,IAAI,CAAC0B,EAAnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAP;AACD,KAFD,CAJF;AAQD;;AAEDC,EAAAA,MAAM,GAAG;AACP;AADO,yBAcH,KAAK1D,KAdF;AAAA,UAGLkB,KAHK,gBAGLA,KAHK;AAAA,UAILyC,OAJK,gBAILA,OAJK;AAAA,UAKL5C,KALK,gBAKLA,KALK;AAAA,UAMLM,WANK,gBAMLA,WANK;AAAA,UAOLuC,UAPK,gBAOLA,UAPK;AAAA,UAQLxC,aARK,gBAQLA,aARK;AAAA,UASLD,aATK,gBASLA,aATK;AAAA,UAULH,UAVK,gBAULA,UAVK;AAAA,UAWLC,cAXK,gBAWLA,cAXK;AAAA,UAYLK,GAZK,gBAYLA,GAZK;AAAA,UAaLC,KAbK,gBAaLA,KAbK;AAgBP,WACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE,oBAAC,MAAD;AAAQ,MAAA,KAAK,EAAEL,KAAf;AAAsB,MAAA,SAAS,EAAC,qBAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF,EAEE;AAAK,MAAA,SAAS,EAAC,gCAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE;AAAK,MAAA,SAAS,EAAC,wBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE;AAAK,MAAA,SAAS,EAAC,wBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAGG,CAACyC,OAAD,IACC,0CACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBADF,EAEE,oBAAC,OAAD;AAAS,MAAA,WAAW,EAAEtC,WAAtB;AAAmC,MAAA,UAAU,EAAEuC,UAA/C;AAA2D,MAAA,KAAK,EAAE1C,KAAlE;AAAyE,MAAA,aAAa,EAAEE,aAAxF;AAAwG,MAAA,KAAK,EAAEF,KAA/G;AAAsH,MAAA,aAAa,EAAEC,aAArI;AAAqJ,MAAA,GAAG,EAAEG,GAA1J;AAA+J,MAAA,KAAK,EAAEC,KAAtK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAFF,CAJJ,CADF,EAWE;AAAK,MAAA,SAAS,EAAC,wBAAf;AAAwC,MAAA,EAAE,EAAC,SAA3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAEGoC,OAAO,IAAI;AAAI,MAAA,SAAS,EAAC,YAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAFd,EAIG,KAAK7C,WAAL,EAJH,EAOGC,KAAK,IAAI,KAAKD,WAAL,GAAmB+C,MAAnB,GAA4B,CAArC,IACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAM,oCAAmC7C,UAAW,GAApD,CARJ,EAaGD,KAAK,IACJE,cAAc,GAAGF,KAAK,CAACU,UAAN,CAAiBoC,MADnC,IAEC,KAAK1D,cAAL,EAfJ,CAXF,CADF,CAFF,CADF;AAoCD;;AAjQ8B,C,CAoQjC;;;AACA,MAAM2D,eAAe,GAAGC,KAAK,IAAI;AAC/B,2BACKA,KADL;AAEEJ,IAAAA,OAAO,EAAEI,KAAK,CAAChD,KAAN,CAAYiD,UAFvB;AAGEjD,IAAAA,KAAK,EAAEgD,KAAK,CAAChD,KAAN,CAAYkD,QAHrB;AAIE5C,IAAAA,WAAW,EAAE0C,KAAK,CAAChD,KAAN,CAAYmD,cAJ3B;AAKEN,IAAAA,UAAU,EAAEG,KAAK,CAAChD,KAAN,CAAYoD,aAL1B;AAME/C,IAAAA,aAAa,EAAE2C,KAAK,CAAChD,KAAN,CAAYqD,gBAN7B;AAOEjD,IAAAA,aAAa,EAAE4C,KAAK,CAAChD,KAAN,CAAYsD,gBAP7B;AAQE9C,IAAAA,KAAK,EAAEwC,KAAK,CAAChD,KAAN,CAAYuD,QARrB;AASEC,IAAAA,IAAI,EAAER,KAAK,CAAChD,KAAN,CAAYyD,OATpB;AAUElD,IAAAA,GAAG,EAAEyC,KAAK,CAAChD,KAAN,CAAY0D,MAVnB;AAWEzD,IAAAA,UAAU,EAAE+C,KAAK,CAAChD,KAAN,CAAY2D,SAX1B;AAYEzD,IAAAA,cAAc,EAAE8C,KAAK,CAAChD,KAAN,CAAY4D;AAZ9B;AAcD,CAfD,C,CAiBA;;;AACA,MAAMC,kBAAkB,GAAG7E,QAAQ,IAAI;AACrC,SAAO;AACLZ,IAAAA,YAAY,EAAE,MAAM;AAClBY,MAAAA,QAAQ,CAACZ,YAAY,EAAb,CAAR;AACD,KAHI;AAILC,IAAAA,UAAU,EAAE,MAAM;AAChBW,MAAAA,QAAQ,CAACX,UAAU,EAAX,CAAR;AACD,KANI;AAOLW,IAAAA;AAPK,GAAP;AASD,CAVD,C,CAYA;;;AACA,eAAeb,OAAO,CACpB4E,eADoB,EAEpBc,kBAFoB,CAAP,CAGblF,QAHa,CAAf","sourcesContent":["import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\n\n// import actions\nimport {\n  fetchLoading,\n  fetchBlogs,\n  fetchSearch,\n  fetchVisibleResults\n} from \"../../../actions/index\";\n\n// import components\nimport Sidebar from \"../../sidebar/sidebar\";\nimport Header from \"../../header/header\";\n\nimport BlogSummary from \"../../blogSummary/blogSummary\";\n\nclass BlogList extends Component {\n  componentDidMount() {\n    // destructure props\n    const { fetchLoading, fetchBlogs } = this.props;\n\n    // display results as soon as we've fetched api is resolved\n    fetchLoading();\n    fetchBlogs();\n  }\n\n  // function is used for the search box,\n  // preventing form from submitting on press of enter key\n  onFormSubmit = event => {\n    event.preventDefault();\n  };\n\n  // listen out for any changes to the search box input\n  // dispatch and update redux store with value entered\n  onChangeInput = event => {\n    // destructure props\n    const { dispatch } = this.props;\n    // prevent search box from submitting any searches\n    event.preventDefault();\n\n    // dispatch the action on key change to update the state of search term\n    dispatch(fetchSearch(event.target.value));\n  };\n\n  infiniteScroll = () => {\n    // hold the stories container and the last article in a const variable\n    const articleContainer = document.getElementById(\"stories\");\n    const lastArticle = document.querySelector(\n      \"#stories > article:last-of-type\"\n    );\n\n    // listen out for scroll events\n    document.addEventListener(\"scroll\", () => {\n      // we're checking if the article is present\n      // as we don't want the function to run an error\n      if (lastArticle !== null) {\n        // check if the article container height minus the window scroll is\n        // equal to or less than the last article height\n        if (\n          articleContainer.scrollHeight - window.scrollY <=\n          lastArticle.scrollHeight\n        ) {\n          // destructure props\n          const { dispatch } = this.props;\n          // dispatch the action so we can update the number of visible results\n          dispatch(fetchVisibleResults());\n        }\n      }\n    });\n  };\n\n  renderBlogs() {\n    // destructure props\n    const { blogs, searchTerm, visibleResults, match, eligibilities, opportunities, skilllevels, age, where } = this.props;\n\n    // set a const variable check if\n    // a searchterm has been entered and filter blogs\n    const filteredBlogs =\n      blogs &&\n      blogs.ChildPages\n        // order blog childpages by most recent post\n        .sort((a, b) => (b.PubDate > a.PubDate ? 1 : -1))\n        // filter blog posts if a searchterm has been entered\n        .filter(blog => {\n          if (searchTerm) {\n            const searchValue = searchTerm.toLowerCase();\n            return Object.values(blog).some(value =>\n              value\n                .toString()\n                .toLowerCase()\n                .includes(searchValue)\n            );\n          }\n          // just return the blog if no searchterm is entered\n          return blog;\n        })\n                // filter this by selected skilllevel in the sidebar links\n                .filter(blog => {\n                  // we're looking at the match params to see if skilllevel is defined\n                  // if it is, we convert the skilllevels in the blog to a string, and lowercase\n                  // then check if the array of skilllevels includes/matches that of the params\n                  if (match.params.skilllevel !== undefined) {\n                    let Array_SkillLevels = [];\n                    Array_SkillLevels.push(blog.SkillLevel)\n                    return Array_SkillLevels.some(value =>\n                      value\n                        .toString()\n                        .toLowerCase()\n                        .includes(match.params.skilllevel)\n                    );\n                  }\n                  // just return all the blogs if params skilllevel is undefined\n                  return blog;\n                })\n        \n        // filter this by selected category in the sidebar links\n        .filter(blog => {\n          // we're looking at the match params to see if category is defined\n          // if it is, we convert the categories in the blog to a string, and lowercase\n          // then check if the array of categories includes/matches that of the params\n          if (match.params.category !== undefined) {\n            return Object.values(blog.Category).some(value =>\n              value\n                .toString()\n                .toLowerCase()\n                .includes(match.params.category)\n            );\n          }\n          // just return all the blogs if params category is undefined\n          return blog;\n        })\n        .filter(blog => {\n          // we're looking at the match params to see if opportunity is defined\n          // if it is, we convert the opportunities in the blog to a string, and lowercase\n          // then check if the array of opportunities includes/matches that of the params\n          if (match.params.opportunity !== undefined) {\n            return Object.values(blog.Opportunity).some(value =>\n              value\n                .toString()\n                .toLowerCase()\n                .includes(match.params.opportunity)\n            );\n          }\n          // just return all the blogs if params opportunity is undefined\n          return blog;\n        })\n        .filter(blog => {\n          // we're looking at the match params to see if category is defined\n          // if it is, we convert the categories in the blog to a string, and lowercase\n          // then check if the array of categories includes/matches that of the params\n          if (match.params.eligibility !== undefined) {\n            return Object.values(blog.Eligibility).some(value =>\n              value\n                .toString()\n                .toLowerCase()\n                .includes(match.params.eligibility)\n            );\n          }\n          // just return all the blogs if params category is undefined\n          return blog;\n        })\n        .filter(blog => {\n          // we're looking at the match params to see if category is defined\n          // if it is, we convert the categories in the blog to a string, and lowercase\n          // then check if the array of categories includes/matches that of the params\n          if (match.params.age !== undefined) {\n            return Object.values(blog.Age).some(value =>\n              value\n                .toString()\n                .toLowerCase()\n                .includes(match.params.age)\n            );\n          }\n          // just return all the blogs if params category is undefined\n          return blog;\n        })\n        .filter(blog => {\n          // we're looking at the match params to see if category is defined\n          // if it is, we convert the categories in the blog to a string, and lowercase\n          // then check if the array of categories includes/matches that of the params\n          if (match.params.where !== undefined) {\n            console.log(\"Running Where filter\");\n            return Object.values(blog.Where).some(value =>\n              value\n                .toString()\n                .toLowerCase()\n                .includes(match.params.where)\n            );\n          }\n          // just return all the blogs if params category is undefined\n          return blog;\n        })\n        .filter(blog => {\n          //AGE\n          // we're looking at the match params to see if category is defined\n          // if it is, we convert the categories in the blog to a string, and lowercase\n          // then check if the array of categories includes/matches that of the params\n          if (match.params.age !== undefined) {\n            console.log(\"Running Age filter\");\n            return Object.values(blog.Age).some(value =>\n              value\n                .toString()\n                .toLowerCase()\n                .includes(match.params.age)\n            );\n          }\n          // just return all the blogs if params category is undefined\n          return blog;\n        });\n\n    // return the data for the const varible set above in filteredBlogs\n    return (\n      filteredBlogs &&\n      // we only want to display as many blogs that are set in the\n      // visibleResults state, so we slice the const and map through the data\n      filteredBlogs.slice(0, visibleResults).map(blog => {\n        return <BlogSummary blog={blog} key={blog.Id} />;\n      })\n    );\n  }\n\n  render() {\n    // destructure props\n    const {\n      match,\n      loading,\n      blogs,\n      skilllevels,\n      categories,\n      opportunities,\n      eligibilities,\n      searchTerm,\n      visibleResults,\n      age,\n      where\n    } = this.props;\n\n    return (\n      <div>\n        <Header match={match} pageTitle=\"Find an opportunity\" />\n        <div className=\"container-wide bg-white pad-30\">\n          <div className=\"pure-g justify-between\">\n            <div className=\"pure-u-1 pure-u-md-1-4\">\n              {/* if the loading of blogs is done, \n              then show  sidebar links */}\n              {!loading && (\n                <>\n                  <h2>Filter</h2>\n                  <Sidebar skilllevels={skilllevels} categories={categories} match={match} opportunities={opportunities}  match={match} eligibilities={eligibilities}  age={age} where={where} />\n                </>\n              )}\n            </div>\n            <div className=\"pure-u-1 pure-u-md-5-8\" id=\"stories\">\n              {/* if loading state is true, then show a loading component */}\n              {loading && <h2 className=\"title is-3\">Loading...</h2>}\n              {/* render blogs once ready */}\n              {this.renderBlogs()}\n              {/* if blog results in zero from user's searchTerm,\n              let's make them aware of this  */}\n              {blogs && this.renderBlogs().length < 1 && (\n                <h3>{`There were no results found for '${searchTerm}'`}</h3>\n              )}\n              {/* if there are blogs and the visibleResults\n              is less than the the amount of childpages \n              then we want to run our infinite scroll function to display more */}\n              {blogs &&\n                visibleResults < blogs.ChildPages.length &&\n                this.infiniteScroll()}\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\n// return store data to const variable 'mapStateToProps'\nconst mapStateToProps = state => {\n  return {\n    ...state,\n    loading: state.blogs.getLoading,\n    blogs: state.blogs.getBlogs,\n    skilllevels: state.blogs.getSkillLevels,\n    categories: state.blogs.getCategories,\n    opportunities: state.blogs.getOpportunities,\n    eligibilities: state.blogs.getEligibilities,\n    where: state.blogs.getWhere,\n    date: state.blogs.getDate,\n    age: state.blogs.getAge,\n    searchTerm: state.blogs.getSearch,\n    visibleResults: state.blogs.getVisibleResults\n  };\n};\n\n// this is used to bind actions and dispatch actions\nconst mapDispatchToProps = dispatch => {\n  return {\n    fetchLoading: () => {\n      dispatch(fetchLoading());\n    },\n    fetchBlogs: () => {\n      dispatch(fetchBlogs());\n    },\n    dispatch\n  };\n};\n\n// connect a react component to our redux store\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(BlogList);\n"]},"metadata":{},"sourceType":"module"}